<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru">
<head>
    <title>Про Тестинг - Автоматизированное Тестирование - Создание системы автоматизированных тестов "с нуля"</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'/>
    <meta content='тесты тестирование автоматизированное система автоматизированных тестов testing компоненты рекомендации оценка требования' name='Keywords'/>
    <meta content='Автоматизированное тестирование. Описание процесса создания и внедрения системы автоматизированных тестов от начала и до конца.' name='Description'/>
    <META content='all' name='robots'/>
    <META content='General' name='rating'/>
    <META content='GLOBAL' name='distribution'/>
    <META content='Testing' name='Classification'/>
    <META content='no-cache' http-equiv='Pragma'/>
    <META content='1' http-equiv='Expires'/>
    <META content='Alexey Bulat' name='author'/>
    <meta name="verify-v1" content="nwLyVjttOGfRojFpAPHmfd1PBGuIk53xCahRkVSccxY=" />
    <link rel="stylesheet" href="../../protesting.css" type="text/css" media="screen" />
    <script language="JavaScript" src="../../js/bookmark.js" type="text/javascript"></script>
    <script type="text/javascript">
        window.___gcfg = {
        lang: 'ru-RU',
        parsetags: 'onload'
        };
        (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
    </script>
</head>
<body>
<div id="fb-root"></div>
<div id="container">
<div id="sitename">
    <a name="top"></a>
    <table border="0" width="100%">
        <tr>
            <td align="left" valign="top">
                <a href="../../index.html" title="Про Тестинг"><img src="../../img/protesting_logo.png" alt="Про Тестинг: обеспечение качества, тестирование, автоматизация" border="0" /></a>
            </td>
            <td align="right" valign="middle">
                <noindex>
                    <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                    <ins class="adsbygoogle"
                         style="display:inline-block;width:728px;height:90px"
                         data-ad-client="pub-6596919741211198"
                         data-ad-slot="6694292302"></ins>
                    <script>
                        (adsbygoogle = window.adsbygoogle || []).push({});
                    </script>
                </noindex>
            </td>
        </tr>
    </table>
</div>
<div id="mainmenu">
    <ul>
        <li><a href="../../index.html">Главная</a></li>
        <li><a href="../../qa/index.html">Обеспечение&nbsp;Качества</a></li>
        <li><a href="../../testing/index.html">Тестирование</a></li>
        <li><a class="current" href="../index.html">Автоматизация</a></li>
        <li><a href="../../service/index.html">Сервис&nbsp;и&nbsp;Услуги</a>
        <li><a href="../../contact/index.html">Контакт</a></li>
        <li><a href="../../news/index.html">Новости</a></li>
    </ul>
</div>
<div id="followme">
    <ul>
        <li><a rel="external nofollow" target="_blank" href="http://twitter.com/ProTesting_RU"><img src="../../img/icons/twitter_1.png" width="36" height="36" title="Следовать за нами в twitter"alt="Twitter" border="0"/></a></li>
        <li><a rel="external nofollow" target="_blank" href="http://pro-testing.blogspot.com/feeds/posts/default"><img src="../../img/icons/rss_1.png" width="36" height="36" title="RSS Atom feed" alt="Atom" border="0"/></a></li>
        <li><a rel="external nofollow" target="_blank" href="http://pro-testing.blogspot.com/"><img src="../../img/icons/blogger_1.png" width="36" height="36" title="Наш блог" alt="Blog" border="0"/></a></li>
    </ul>
    <g:plusone align="right"></g:plusone>
    <div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="false" data-share="false"></div>
</div>
<div id="wrap">
<div id="leftside">
    <h1>Автоматизация тестирования ПО</h1>
    <p>
        <a class="nav" href="../index.html">Основные понятия</a>
        <a class="nav" href="../performance.html">Нагрузочное Тестирование</a>
        <a class="nav" href="../functional.html">Автоматизация функционального тестирования</a>
    </p>
    <p>
        <a class="nav" href="index.html">Практикум</a>
        <a class="nav sub active" href="automation_from_scratch.html">Пишем систему автоматизации тестов "с нуля"</a>
        <a class="nav sub" href="pageobject_pattern.html">PageObjects pattern</a>
        <a class="nav sub" href="pageobject_selenium.html">PageObjects pattern + Selenium (Java)</a>
        <a class="nav sub" href="static_resources.html">Работа со статическими ресурсами</a>
        <a class="nav sub" href="start_selenium_server.html">Запуск Selenium Server</a>
        <a class="nav sub" href="work_load_model.html" title="Модель нагрузки, как отправная точка при тестировании производительности">Модель нагрузки, как отправная точка при тестировании...</a>
        <a class="nav sub" href="test_stand_configuration.html" title="Конфигурация тестового стенда для нагрузочного тестирования">Конфигурация тестового стенда для нагрузочного тестирования</a>
        <a class="nav sub" href="load_scripts_writing.html" title="Разработка скриптов для нагрузочного тестирования">Создание скриптов для нагрузочного тестирования</a>
        <a class="nav sub" href="javatestrunner.html" title="Java Test Runner">Запуск скриптов: Java Test Runner</a>
        <a class="nav sub" href="atfwk.html" title="Automation Test Framework (ATFwk)">Automation Test Framework (ATFwk)</a>
    </p>
</div>
<div id="rightside">
    <noindex>
        <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <!-- Большой вертикаль - 160x600 -->
        <ins class="adsbygoogle"
             style="display:inline-block;width:160px;height:600px"
             data-ad-client="ca-pub-6596919741211198"
             data-ad-slot="9317658806"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
    </noindex>
</div>
<div id="searchpanel">
    <form action="http://www.protesting.ru/searchresult.html" id="cse-search-box">
        <input type="hidden" name="cx" value="partner-pub-6596919741211198:2p1g8mczggq" />
        <input type="hidden" name="cof" value="FORID:10" />
        <input type="hidden" name="ie" value="UTF-8" />
        <input class="searchbox" type="text" name="q" size="50" onblur="if (q.value == '') {q.style.background = '#FFFFFF url(http://www.protesting.ru/img/search-logo.PNG) left no-repeat';}" onfocus="q.style.background = '#ffffff'; "/>
        <input class="searchbutton" type="submit" name="sa" value="&#x041f;&#x043e;&#x0438;&#x0441;&#x043a;" />
    </form>
</div>
<div id="content">
<div id="bookmark">
    <div id="addBookmarkContainer"><a id="bookmarkLink">&nbsp;►&nbsp;в&nbsp;закладки&nbsp;&nbsp;</a></div>
</div>
<p class="broadcast">Раздел: <a href="../index.html">Автоматизация</a>&nbsp;&gt; <a href="index.html">Практикум</a>&nbsp;&gt; Пишем систему автоматизированных тестов "с нуля"</p>
<h1>Пишем систему автоматизированных тестов "с нуля"</h1>
<br/>
<h2>Оглавление</h2>
<div id="toc">
    <ol>
        <li><a href="automation_from_scratch.html#1">Определяем требования к системе</a></li>
        <li><a href="automation_from_scratch.html#2">Определяем компоненты системы</a></li>
        <li><a href="automation_from_scratch.html#3">Определяем компоненты, которые необходимо разрабатывать</a></li>
        <li><a href="automation_from_scratch.html#4">Проводим оценку объемов работы</a></li>
        <li><a href="automation_from_scratch.html#5">Разработка. Практические рекомендации</a>
            <ol>
                <li><a href="automation_from_scratch.html#51">Web / GUI</a></li>
                <li><a href="automation_from_scratch.html#52">Файловая система</a></li>
                <li><a href="automation_from_scratch.html#53">Сервисы и демоны</a></li>
                <li><a href="automation_from_scratch.html#54">Базы данных</a></li>
                <li><a href="automation_from_scratch.html#55">Отчеты</a>
                    <ol>
                        <li><a href="automation_from_scratch.html#551">Содержимое результатов автоматизированного теста</a></li>
                        <li><a href="automation_from_scratch.html#552">Хранение результатов автоматизированных тестов</a></li>
                        <li><a href="automation_from_scratch.html#553">Содержание отчета</a></li>
                        <li><a href="automation_from_scratch.html#554">Рассылка результатов</a></li>
                    </ol>
                </li>
            </ol>
        </li>
        <li><a href="automation_from_scratch.html#6">Визуализация работы</a></li>
    </ol>
</div>
<h2>Пару слов о том, кому это может пригодиться:</h2>
<p>Данный материал в первую очередь адресован тем, кто уже имеет некий опыт автоматизации небольших и средних проектов, но, по какой-то причине, не представляет общей картины, либо не представляет в каких направлениях можно развивать автоматизированную систему. Все нижеизложенное основано, в первую очередь, на практическом личном опыте и, надеюсь, поможет вам правильно расставить приоритеты, сделать оценки и избежать подводных камней.</p>
<p>Удачной автоматизации и извините за англизмы...</p>
<br/>
<a name="1"></a><h2>1. Определяем требования к системе автоматизированного тестирования</h2>
<p>Начало всех начал – выяснение того, что придется делать, иными словами – определение скоупа системы. Для успешного решения этой задачи лучше всего использовать технику брэйншторминга:</p>
<ul>
    <li/>Соберите на митинг всех, кто заинтересован в автоматизации тестирования. Также пригласите тех, кто потенциально может получить выгоду (речь не только о финансовой выгоде) от внедрения автоматизации тестирования.
    <li/>Коротко расскажите им об автоматизации – покажите на примерах как это поможет конкретно вам сделать процесс тестирования более эффективным. Какие будут получены преимущества в качестве конечного продукта, оценках тестопригодности билдов, увеличение объемов проверяемых данных.
    <li/>Ваше видение автоматизации – это только часть той работы которую предстоит сделать. Чаще всего вы не знаете всех проблем проекта и всех пожеланий его участников. У каждого участника могут быть свои требования к новой системе (объем покрытия, фичи, сервисы). На этом этапе выпишите все идеи для системы автоматизированного тестирования (например – поддержка автотестестами нескольких платформ). Пока что избегайте критики каких-либо высказываний (и активно требуйте этого от других участников!) – просто перечисляйте то, что вам хотелось бы получить.
    <li/>Когда все требования и идеи выписаны - приходит время трезвой оценки своих возможностей. Критически оцените написанное и выкиньте совсем уж бредовые идеи и требования. Если таковых не нашлось – с вами работают вполне вменяемые коллеги!
    <li/>Расставьте приоритеты начиная с того, что проще всего сделать и что будет полезно (выгодно) наибольшему количеству участников. Помните правило – 20% функционала используются в 80% случаев! Найдите эти 20% и поставьте им высший приоритет. Лучше будет в первую очередь разрабатывать компоненты, которые можно сложить в законченную систему. Например, как в следующей главе.
</ul>
<a name="2"></a><h2>2. Определение компонентов системы.</h2>
<p>На самом деле у вас скорее всего будет ваша, эксклюзивная система с индивидуальным набором компонентов. Не факт, что вам пригодятся все компоненты, описанные ниже. Также, вероятно, для именно вашей системы, придется придумать дополнительные компоненты – для этого и нужно определить требования к ней (см. предыдущую главу). В любом случае, следующий перечень позволит представить и оценить некую типовую инфраструктуру автотестов и показать, что собственно тесты – это лишь небольшая (хоть и самая важная) ее часть.</p>
<ul>
    <li><i><b>Автоматический инсталлятор приложения</b>,</i> а также сопутствующая ему функциональность для получения новой версии из репозитория, ftp, либо другого места куда автоматически выкладываются сборки поможет вам избежать выполнения всех этих действий вручную, а значит – освободит время на другие задачи.</li>
    <li><i><b>Автоматизированные тесты (скрипты + фреймворк для их выполнения)</b>.</i> Этот компонент включает всю инфраструктуру тестов - компоненты для работы с удаленной и локальной файловой системой, сервисами/демонами, фреймворк для работы с формами приложения и, собственно, сами тест-скрипты. Только не спешите покрывать ими все приложение в самом начале разработки. Лучше имплементировать сразу только небольшую часть. Во-первых, имплементация всех тестов – это невероятно большой объем работы. Во-вторых - это не даст вам, впоследствии, заниматься другими задачами, так как будет требовать много времени на поддержку, запуск и рассылку результатов вручную. В-третьих – при последующей реализации других компонентов вы можете столкнуться с проблемой, решение которой потребует полного либо частичного изменения кода тестов – и чем меньше этого кода, тем оперативнее вы сможете его изменить. В общем, 2-4 тестов будет вполне достаточно для начала. После завершения реализации остальной инфраструктуры вы сможете к ним вернуться. На самом деле тесты – сами по себе большая тема. Подробнее об их рациональной организации – в последующих главах.</li>
    <li><i><b>Автоматический деинсталлятор приложения</b>.</i> Его лучше будет вызывать перед инсталляцией новой версии. Это также освобождает время на другие задачи. Вместо него можно использовать полное восстановление системы (например, из полного бэкапа диска). Такое восстановление дает гарантию отсутствия проблем из-за неверно функционирующей денисталляции, что идет на пользу стабильности автотестов.</li>
    <li><i><b>Автоматизированная система восстановления рабочей среды</b>. </i>Часто взаимодействие с системой – это необратимый процесс. Т.е. создав в ходе теста какой-либо элемент и использовав его в более сложных структурах вы теряете возможность удалить его из системы. Также если система осуществляет оборот документов – после изменения статуса документа вы не можете удалить документ, либо вернуть ему исходный статус. Часто невозможно создавать сущности с одинаковыми свойствами (например – пользователей с одинаковым именем). Для решения этих проблем необходима инфраструктура, обеспечивающая восстановление рабочей среды (уже установленного приложения + сопутствующего ПО) в эталонное состояние перед запуском каждого нового теста. Это требует дополнительного времени, но только так вы можете гарантировать отсутствие влияния результатов выполнения одного теста на последующие. Пример: в результате ошибки в приложении в системе сохранился пользователь с именем FIRST, это же имя используется для создания пользователя в ходе другого теста. Второй тест также всегда закончится ошибкой, так как пользователь FIRST уже существует. Самая простая реализация – это создание перед выполнением теста бэкапа изменяемых частей системы, если этот бэкап еще не был создан. Если бэкап существует (например был создан перед выполнением 1-го теста сразу после инсталляции приложения) – то восстановление состояния системы из этого бэкапа. Такая реализация позволяет создать «снимок» системы до того как первый тест будет выполнен и впоследствии использовать его для всех остальных тестов.</li>
    <li><i><b>Автоматизированная система хранения результатов автоматических тестов</b>. </i>Для построения графиков ретроспективы, выявления ошибок в тестах, оценки динамики роста/падения качества приложения необходимы не только последние, но и предыдущие результаты автотестов. Лучше хранить их в базе данных, так как она обеспечивает более богатые возможности манипуляции данными. В моей практике также встречалась файловая система - для небольших проектов это допустимо, так как разработка предельно проста, но когда данных становится много скорость работы такой системы вызывает дискомфорт.</li>
    <li><i><b>Автоматизированная система формирования и рассылки результатов тестов</b>.</i> Сюда можно также добавить графики (но лучше - таблицы) истории выполнения автотестов со ссылками на соответствующие логи. Это отличный способ визуализации работы команды автоматизации! Текущее качество продукта, а также покрытие и качество тестов станут очевидны подписанным на данную рассылку. Это дает менеджерам проекта ощущение направления в котором движется разработка. А уже через пару месяцев любая задержка рассылки заставляет их нервничать и интересоваться причинами.</li>
</ul>
<a name="3"></a><h2>3. Определение компонентов для разработки</h2>
<p>На самом деле в реальности ни одна разработка в наше время не делается полностью «с нуля», так как глупо не использовать уже готовые и достаточно стабильные компоненты и библиотеки. Скорее такая разработка сводится в выбору наиболее подходящих для задачи компонентов и написания интеграционного кода для них. Возможно, также, небольшая кастомизация компонентов с открытым кодом под собственные нужды (только не стоит увлекаться – можно получить несовместимость с обновлениями таких компонентов). Впрочем, если обновления для вас не критичны – дерзайте, но помните, что в них (обновлениях) может появиться нужный вам функционал, либо могут быть исправлены критические ошибки.</p>
<p>На данном этапе вы уже должны определиться со списком и приоритетами задач по автоматизации и решить, какие задачи решать с помощью готовых компонентов, а что разрабатывать самому. Я постараюсь перечислить модули и проекты, которые могут оказаться полезны при реализации компонентов, описанных в предыдущей главе.</p>
<ul>
    <li><i><b>Автоматический инсталлятор приложения</b>.</i>
        <ul>
            <li/>Для GUI инсталляций можно использовать любой инструмент, который поддерживает API целевой системы. Для Windows подойдет, например, AutoIT 3.
            <li/>Silent install из командной строки поддерживается для многих типов инсталляторов.
            <li/>OpenSsh поможет получить доступ к командной строке на удаленном сервере.
            <li/>SFTP протокол позволит передавать файлы конфигурации на сервер и логи – обратно.
            <li/>Jsch – java-библиотека, которая позволяет соединяться с удаленным сервером используя SSH и SFTP.
        </ul>
    </li>
    <li><i><b>Автоматизированные тесты</b> <b>(скрипты + фреймворк для их выполнения)</b>.</i>
        <ul>
            <li/>Для взаимодействия с файловой системой подойдут те же компоненты что и для инсталляции.
            <li/>Для взаимодействия с GUI интерфейсами приложения можно воспользоваться как платными (QTP, WinRunner, SilkTest, Rational Functional Tester, TestComplete), так и бесплатными инструментами и java-библиотеками (HtmlUnit, HttpUnit, Selenium, WATIJ, Abbot) либо использовать другой инструмент, позволяющий распознавать элементы управления Вашего приложения.
        </ul>
    </li>
    <li><i><b>Автоматический деинсталлятор приложения</b>.</i>
        <ul>
            <li/>Актуальны те же компоненты что и для автоматической инсталляции.
        </ul>
    </li>
    <li><i><b>Автоматизированная система восстановления рабочей среды</b>. </i>
        <ul>
            <li/>DB-интерфейс используемой приложением базы данных позволит вам сделать бэкап и восстановить его. Многие базы используют интерфейс командной строки. В этом случае можно использовать те же компоненты что и для инсталляции.
            <li/>Для доступа к web-интерфейсу можно использовать те же компоненты что и для тестов.
            <li/>Манипулировать демонами и сервисами можно с помощью командной строки. Помните, что демоны и сервисы могут блокировать доступ к некоторым файлам и пока сервисы работают заменить такие файлы копиями из бэкапа невозможно! В этом случае придется писать код для старта и остановки этих сервисов.
        </ul>
    </li>
    <li><i><b>Автоматизированная система хранения результатов автоматических тестов</b>. </i>
        <ul>
            <li/>Если для хранения результатов автоматических тестов вы используете тот же тип базы данных что и приложение (это совсем не обязательно) можете использовать те же компоненты, иначе – используйте интерфейс той базы данных (web, command line), в которой вы храните тесты, либо command line для доступа к файловой системе.
        </ul>
    </li>
    <li><i><b>Автоматизированная система формирования и рассылки результатов тестов</b>.</i>
        <ul>
            <li/>Здесь проще использовать собственные java-классы, либо shell/vba скрипты, так как функционал несложный, а найти такой бесплатный инструмент, который полностью удовлетворял бы желаемому вами формату – непросто. Но поискать все же стоит – это может сэкономить вам время потом.
        </ul>
    </li>
</ul>
<p>На данном этапе вам нужно будет определиться с начальным набором сторонних компонентов, которые вы будете использовать. К выбору нужно подходить осознавая тот факт, что замена одного компонента может вылиться в значительную переработку кода. Тем не менее излишне задерживаться с выбором тоже не стоит. К примеру, если у вас есть 2 библиотеки, которые покрывают ваши нужды на 90%, вы можете потратить очень много времени лишь сравнивая их возможности в надежде выявить наиболее подходящую. На этапе выбора редко получается предвидеть все случаи использования библиотеки, поэтому сделать "100% правильный выбор" за разумное время практически невозможно. Если вы стоите перед похожей дилеммой (~90% / ~90%) попробуйте начать использовать ту библиотеку, которая вам больше нравится (к примеру - имеет более понятный и продуманный API). Примерно за то же время что вы проведете сравнивая 2 библиотеки и получив результат "наверное подходит" / "наверное не подходит", вы сможете получить более точную информацию "подходит" / "не подходит" об одной из них. Это гораздо более полезная информация. К тому же, если библиотека вам подходит, вы получите выигрыш во времени - ведь вы уже начали ее использовать!</p>
<br/>
<a name="4"></a><h2>4. Оценка объемов работы.</h2>
<p>После того как выбор компонентов закончен, есть резон потратить некоторое время на осмысление того, что вам предстоит сделать. Естественно, готовые компоненты не нуждаются в оценке. Оценивать нужно работу по их интерграции в вашу систему.</p>
<p>Оценку лучше делать после того как вы дочитаете статью до конца - возможно некоторые вещи станут более понятны.</p>
<p>Существует много методик оценок времени на разработку, однако, в основном, они опираются на предыдущий опыт. Я приведу здесь пару ссылок на англоязычные ресурсы, которые считаю полезными:</p>
<p><a target="_blank" href="http://www.stellman-greene.com/aspm/images/ch03.pdf">Estimation</a></p>
<p><a target="_blank" href="http://en.wikipedia.org/wiki/Estimation_in_software_engineering">Estimation in software engineering</a></p>
<p>От себя добавлю чуть-чуть:</p>
<ul><li>Если вы знаете как решить проблему с помощью известного вам инструментария - лучше решить эту проблему именно таким способом. Вы сможете запланировать время исходя из предыдущего опыта. Если кто-то где-то сделал более эффективную систему используя другой инструментарий - не обольщайтесь - скорее всего в реализации есть множество нюансов на нахождение которых вы потратите времени больше, чем выиграете. Не хочется отговаривать от освоения использования новых технологий, но лучше заняться этим в случае если результат не критичен, либо не критично время на разработку, либо в свободное от работы время :)</li>
    <li>Если вы не занимались планированием раньше - лучше спросить совета у тех кто занимался и, желательно, трудится на том же проекте. Конкретные рекомендации давать очень сложно - слишком разные бывают начальные условия, именно поэтому книги по оценкам оперируют достаточно общими терминами.    </li>
</ul>
<br/>
<a name="5"></a><h2>5. Разработка. Практические рекомендации.</h2>
<p>Всегда помните о том, что не существует универсальных рецептов! Можно рассматривать частные случаи, можно рассматривать рекомендации, но 100% ситуаций нельзя эффективно покрыть <font class="Apple-style-span"><span style="background-color:#ffffff">используя один подход</span></font>. Поэтому отнеситесь к нижеизложенному критически. Это то, что работало для меня, но ваша система скорее всего имеет отличия.</p>
<p>Итак, начнем с алгоритма работы инфраструктуры тестов. Он может быть таким:</p>
<div style="text-align:center;"><img src="../../img/block_schema.PNG" style="height:940px;width:599px" alt="Схема системы автоматизации"/></div>
<p>Как видно из схемы, алгоритм, в общем, несложный. Я сознательно опустил полное восстановление системы, так как оно не везде нужно. Основная сложность будет заключаться в безглючной реализации всех этих&nbsp; действий и связывании их в одну работающую систему. Причем должны правильно обрабатываться все ситуации - это обязательно нужно проверять после любых внесенных в алгоритм изменений! <br/>
    Выбор языка реализации за вами, но необходимо убедиться что язык поддерживается на всех необходимых вам платформах. Например для обеспечения кроссплатформенности Linux + Windows + AIX прекрасно подходит Perl и Java.</p>
<br/>
<a name="51"></a><h3>5.1 WEB/GUI</h3>
<p>В этой части хотелось бы главным образом коснуться архитектуры, позволяющей эффективно работать с форм-ориентированными приложениями, а также позволяющей эффективно использовать код автотестов.<br/>
    <br/>
    То, с чего почти все начинают написание автотестов - это рекординг. Т.е. простая запись последовательности нахождения и заполнения/нажатия/выбора элемента активной формы. В результате такого рекординга, как правило, создается скрипт и набор свойств элементов с которыми этот скрипт взаимодействует (либо как отдельный файл, либо как часть того же скрипта). Причем данные, которые использовались при заполнении формы скорее всего находятся тут же - в скрипте.<br/>
    <br/>
    Посмотрим, как может быть улучшен такой скрипт. Для простоты предположим, что выбранный нами инструмент поддерживает объектно ориентированный подход - то есть мы можем создавать классы, иерархии классов (с наследованием) и использовать в тестах экземпляры этих классов. Пойдем от простого к сложному.<br/>
    <br/>
    <b><i>1. Выделяем классы форм</i></b><br/>
    Для каждой формы создаем отдельный класс, в котором содержатся методы для работы с ней (проверка что данная форма загружена, внесение/проверка данных в элементах формы, навигация на другие формы, закрытие формы и т.п.). Таким образом тест будет представлять уже не беспорядочный набор операций (смысл которых может стать понятен не сразу), а набор параметризованных операций с формами.<br/>
    Пример:<br/>
</p>
<pre class="code">
    Application.startNewInstance();
    LoginForm login = (LoginForm) Application.getCurrentForm();
    MainForm main = login.login("user","password");
    login = main.logout();
</pre>
<p>Даже без доступа к коду функций login и logout понятно, что должно происходить в тесте. А это значит, что для разбора проблем и внесения изменений потребуется гораздо меньше времени!<br/>
    Этот подход был недавно описан в <a target="_blank" href="http://code.google.com/p/selenium/wiki/PageObjects?redir=1" id="lpif" title="блоге Google">блоге Google</a>, впрочем, это не мешало успешно использовать его задолго до этого описания на некоторых проектах, в которых мне посчастливилось принимать участие.<br/>
    <br/>
    <b><i>2. Выносим общие методы взаимодействия с элементами из классов форм в общий суперкласс</i></b><br/>
    Создаем класс от которого наследуются все формы и выносим в него общие методы для взаимодействия с элементами. Это очень удобно, если к примеру,&nbsp; сначала элемент нужно найти, затем активировать, а затем установить в него данные. Суперкласс позволяет описать эти последовательности действий в одном месте и впоследствии быстро и безболезненно вносить в них изменения. Также сюда можно вынести методы, проверяющие что именно эта форма открыта и активна (например - по уникальному ключевому элементу управления находящемуся на форме, по заголовку, http и т.п.). Также здесь можно реализовать настраиваемую паузу перед/после взаимодействия с элементами управления и т.п.<br/>
    <br/>
    <b><i>3. Выносим данные теста из скрипта в подгружаемый файл (поддержка Data-Driven testing)</i></b><br/>
    Создаем файл (например в var=value формате) в который выносим все данные которые используются в скрипте. Подгружаем эти данные во время выполнения. Это позволяет запускать один и тот же скрипт используя разные данные для него. Можно создать несколько наборов, либо генерировать наборы данных "на лету". Эта концепция реализована в софте от Rational (ныне - подразделение IBM) и называется такой набор данных datapool, правда сделано жутко криво и неудобно, но никто не мешает сделать собственную реализацию, как это сделали мы. Кстати, это попутно решило кучу проблем.<br/>
    <br/>
    <i><b>4. Создаем кейворды (поддержка Keyword-Driven testing)</b><br/>
    </i>Кейворды - это мини-скрипты. Например, кейворд логина может запускать страницу логина, проверять что она открыта, заполнять поля логина и пассворда нужными значениями, нажимать кнопку логина, проверять что пользователь успешно залогинен. И все это - с помощью одного метода! Для этого вам нужно будет создать библиотеку кейвордов. Кейворд может оперировать несколькими страницами.<br/>
    <br/>
    К примеру тест может выглядеть так :<br/>
    <pre class="code">        KwrdLib.getKeyword("login").execute(new String[] {"user", "password"});
        KwrdLib.getKeyword("createNewUser").execute(new String[] {"user2", "password2"});
        KwrdLib.getKeyword("logout").execute(new String[] {});
        KwrdLib.getKeyword("login").execute(new String[] {"user2", "password2"});
        KwrdLib.getKeyword("logout").execute(new String[] {});
    </pre>
<i>Джедаи java 1.6 могут вообще использовать <a target="_blank" href="http://www.codemiles.com/java-examples/java-enum-example-t3860.html" title="Java Enums">Enum</a> с <a target="_blank" href="http://docs.oracle.com/javase/tutorial/reflect/" title="Java Reflections">Reflections</a>, чтобы синтаксис обращений к кейвордам заставлял глаз радоваться, но это материал для другой статьи</i>.<i> Б</i>удет <i>выглядеть примерно так:<br/></i>
    <pre class="code">        LOGIN.execute(new String[] {"user", "password"});
        CREATE_NEW_USER.execute(new String[] {"user2", "password2"});
        ...</pre>
<br/>
Соответственно, в классе KwrdLib будет статический метод getKeyword который будет возвращать экземпляр нужного класса кейворда по имени (с точки зрения java-программирования логичнее, конечно, использовать здесь <a target="_blank" href="http://docs.oracle.com/javase/tutorial/reflect/" title="Java Reflections">Reflections</a>).<br/>
    <pre class="code">        public static Keyword getKeyword(String keywordName) {
            ...
            if (keywordName.equals("login")) {
                return new LoginKeyword();
            }
                ...
            }
        }
    </pre>
А уже непосредственно в классе кейворда будет описана манипуляция с формами:<br/>
    <pre class="code">
    public void execute(String[] data) {
        //проверяем что набор данных достаточный
        if (data.length &lt; 2) {
            throw new RuntimeException("Invalid dataset for LoginKeyword: at least 2 params should be provided.");
        }
        //проверяем что открыта нужная форма
        if (!(Application.getCurrentForm() instanceof LoginForm)) {
            throw new RuntimeException("Invalid form opened: " + Application.getCurrentForm() + "; Expected: LoginForm");
        }
        //выполняем процедуру логина
        LoginForm login = (LoginForm) Application.getCurrentForm();
        MainForm main = login.login("user","password");
        //сохраняем текущую форму
        Application.setCurrentForm(main);
    }</pre>
В примере использован java код так как этот язык весьма универсален и обеспечивает богатые возможности работы с классами. Те же примеры (например библиотека кейвордов) могут быть более удобно организованны с помощью Enum классов, но здесь упор сделан в первую очередь на понятность концепции. <br/>
Также из примера видно, что кейворд подразумевает начало выполнения с определенной формы и завершение выполнения на определенной форме. Очень хорошо, если вы сможете организовать свои кейворды таким образом, чтобы большинство из них (&gt;90%?) начинались и заканчивались на одной и той же открытой форме - например это может быть окно основного приложения в исходном состоянии.<br/>
PS <font face="courier new">Класс Application</font> - это вспомогательный класс для работы с приложением. В нем можно хранить текущее состояние, методы вызова, закрытия и возврата в "исходное состояние" тестируемого приложения. Оформить можно в виде синглетона.<br/>
</p>
<br/>
<a name="52"></a><h3>5.2 Файловая система</h3>
<p>Для работы с файловой системой очень удобно написать свой интерфейс. Причем вы в дальнейшем сможете использовать его на других проектах! Вам может понадобится также работать с удаленными файловыми системами и очень здорово, если интерфейс будет одинаковый! Т.е. вы можете работать с объектами через интерфейс не думая о том локальная это файловая система или удаленная!<br/>
    Например в моей практике был успешно реализован единый интерфейс для работы с локальной системой через Java Virtual Machine из которой запускались тесты и с удаленными файловыми системами WINDOWS AIX и LINUX через SSH с помощью библиотек jsch и j2ssh.<br/>
    <br/>
    <i><b>Уделите внимание таким операциям как:</b></i><br/>
</p>
<ul>
    <li>копирование/создание/удаление/проверка существования файлов</li>
    <li>архивация/разархивация файлов и каталогов</li>
    <li>копирование файлов с/на целевую файловую систему</li>
    <li>поиск в файлах по паттерну (логи) / изменение содержимого текстовых файлов (конфиги)</li>
    <li>выполнение команд на удаленной системе и получение стандартного вывода (stdout) и ошибок (errout) от них.</li>
</ul>
<br/>
<a name="53"></a><h3>5.3 Сервисы и демоны</h3>
<p>Если вам приходится управлять состоянием сервисов/демонов на различных платформах, также удобно иметь единый интерфейс, который будет прятать реализацию (последовательность и синтаксис команд) управления сервисами/демонами для конкретной платформы. В этом случае вам не нужно будет постоянно помнить о том, на какой платформе приходится работать. Опять же, проще добавить поддержку новых платформ, т.е. ваша система становится более расширяемой.<br/>
    <br/>
    Общий алгоритм такой:<br/>
    1. Проверка состояния.<br/>
    2. Если сервис/демон уже в нужном состоянии - выход.<br/>
    3. Если достигнут таймаут запуска/остановки сервиса - выход с ошибкой.<br/>
    4. Если сервис/демон в промежуточном состоянии (starting|stopping) - ждем таймаут и идем на шаг1.<br/>
    <b>5. Отдаем команду запуска/остановки сервиса.</b><br/>
    6. Проверка состояния.<br/>
    7. Если сервис/демон в нужном состоянии - выход.<br/>
    8. Если достигнут таймаут запуска/остановки сервиса - выход с ошибкой.<br/>
    9. Если сервис/демон в промежуточном состоянии (starting|stopping) - ждем таймаут и идем на шаг6.<br/>
</p>
<p>Шаги 1-4 и 6-9 похожи - можно оптимизировать, но для понятности здесь не буду этого делать :)</p>
<br/>
<a name="54"></a><h3>5.4 Базы данных</h3>
<p>Единый интерфейс для работы с базами данных будет полезен, если тестируемое приложение должно поддерживать работу на нескольких типах баз данных. Соответственно, есть потребность тестировать приложение на каждой такой базе. В этом случае полезно использовать hibernate, если вы пишете тесты на Java и структура баз одинакова. Если структура баз разная, то каждая такая структура потребует отдельный набор классов. Hibernate и тут будет полезен, но не настолько эффективен как при одинаковой структуре баз. Впрочем если в java-приложении сужествует поддержка нескольких типов баз, то Hibernate скорее всего уже используется, и, вероятнее всего, структура баз будет одинакова.
</p>
<br/>
<a name="55"></a><h3>5.5 Отчеты</h3>
<p>Еще одна большая тема. Всегда нужно помнить о том что отчеты - это результат вашей работы. То есть именно по нему будут судить о вас и о вашей работе. Нерегулярные, плохочитаемые(представление информации) и неинформативные(содержание) отчеты будут только занимать место в почтовом ящике - вряд ли кто-то станет их читать.&nbsp;</p>
<br/>
<a name="551"></a><h4>5.5.1 Содержимое результатов автоматизированного теста</h4>
<p>В результате выполнения теста для последующего анализа полезно получить и сохранить следующую информацию (список можно расширить по необходимости):</p>
<ul>
    <li>Время начала выполнения теста </li>
    <li>Время завершения выполнения теста</li>
    <li>Результат (passed / failed / blocked)</li>
    <li>Полный лог выполнения теста и крайне желательно - с метками времени для каждой записи в логе        </li>
    <li>Номер билда для которого проводился тест</li>
    <li>Конфигурация (аппаратная платформа + настройки) на которой проводился тест. (Актуально только если используется несколько конфигураций)</li>
    <li>Скриншот (в сучае отличного от passed результата)</li>
</ul>
<p>Естественно, все можно кастомизировать под ваши нужды. Например - добавить сбор и архивацию определенных логов с сервера для упрощения анализа ошибок. Своеобразный снимок енвайрмента.</p>
<a name="552"></a><h4>5.5.2  Хранение результатов автоматизированных тестов</h4>
<p>Лучше всего использовать для этих целей БД, например ClearQuest, MySQL, Postgre, либо другую. Но для небольших проектов пойдет и файловая система.</p>
<br/>
<a name="553"></a><h4>5.5.3  Содержание отчета</h4>
<p>Опытным путем я пришел к следующему формату отчета (у вас он, естественно, может отличаться):<br/>
    <b>Заголовок:</b>
</p>
<ul><li>Конфигурация (если их несколько)</li>
    <li>Билд</li>
    <li>Количество запущенных тесткейсов</li>
    <li>Количество успешно завершенных тесткейсов<br/>
    </li>
</ul>
<b>Текст:</b><br/>
<ul><li>Подробное описание конфигурации и параметров, на которых проводился тест.</li>
    <li>Статистика реультатов (passed / failed / blocked) теста<br/>
    </li>
    <li>Полная таблица с самоописательными названиями тесткейсов и их результатами passed / failed / blocked (со ссылкой на детальную информацию о результате - см. <a href="automation_from_scratch.html#551">5.5.1</a>).<br/>
    </li>
    <li>Ссылка на историю результатов (если ее можно где-нибудь посмотреть)<br/>
    </li></ul>
<p>Полезно иметь инструмент позволяющий по вашим результатам тестов составить историю - по ней можно сравнивать результаты для разных билдов, смотреть когда последний раз тест кейс был успешно выполнен и т.п. Т.е. вообще такой инструмент относится к украшательствам и может быть выполнен в последюю очередь, но иметь его под рукой очень удобно как для анализа результатов тестов, так и для презентации вашей системы автоматизированного тестирования, так как результаты в таком представлении наиболее наглядны.</p>
<a name="554"></a><h4>5.5.4 Рассылка результатов</h4>
<p>Рассылайте ваши отчеты:</p>
<ul><li>Менеджеру(ам) проекта</li>
    <li>Менеджеру(ам) по тестированию</li>
    <li>Тестлиду(ам)</li>
    <li>Всем, кто попросит!!! (см. следующую главу)</li>
</ul>
<a name="6"></a><h2>6 Визуализация работы</h2>
<p>Самый интересный вопрос автоматизации - а как же сделать так, чтобы всю эту сложную и творческую работу вам дали довести до победного финала? Объем задач не маленький, а собрать в одну команду нескольких толковых автоматизаторов получается отнюдь не всегда (впрочем были в моей практике такие команды - нужно только сильно захотеть и иметь в запасе хотя бы год на подбор сотрудников). То есть часто приходится работать одному, максимум - вдвоем. <br/>
    <br/>
    Давайте представим как выглядит автоматизатор тестов со стороны в начале работы над проектом. Приходит на работу с утра, смотрит весь день в монитор, стучит по клавишам, вечером собирается и уходит. На вопросы менеджера о текущей работе засыпает его деталями и проблемами, на вопросы менеджера о готовности отсылает в далекую перспективу. Также может периодически требовать дополнительные рабочие станции. Разработчики менеджеру в понимании происходящего помочь могут весьма условно, так как у них другая специфика работы. <br/>
    Если на вашем проекте все именно так и происходит - сделаю ставку на то, что автоматизация закончена и внедрена не будет. Ведь менеджер - это тот кто должен обеспечить выполнение проекта в сроки, а также его рентабельность. И если ему непонятно чем занимается на проекте человек - значит в его глазах это пустая трата проектных средств. Именно поэтому автоматизатора будут постоянно пытаться занять другой "полезной" работой - ручными тестами, поддержкой тестовой лаборатории или программированием - ведь эти задачи хорошо визуализируются (т.е. видны, ясны и понятны менеджеру). <br/>
    Знакомо?<br/>
    &nbsp;&nbsp; &nbsp;<br/>
    Кроме возможности довести работу до конца, визуализация дает ряд побочных положительных эффектов:<br/>
</p>
<ul><li>Фидбек - Очень здорово, когда написанную вами систему использует еще кто-то и делится идеями по улучшению. Часто "замыленным" взглядом не видно простых вещей. Чем больше людей знают о вашей системе и о том как она работает - тем больше поступает фидбека! Лично я позитивному неконструктивному фидбэку (" - Молодец! Отличная работа! Спасибо! Так держать! и т.п.")&nbsp; предпочитаю негативный, но конструктивный фидбек (" - Если вот это переделать вот так - будет работать быстрее в 2 раза, а наглядность только улучшится!" или "эта настройка не нужна - ей все равно никто не пользуется"). Думаю не надо объяснять - почему :)</li>
    <li>Правильная приоритезация работы - Визуализация - это работа по принципу agile. Чтобы быть все время "на виду" нужно как можно быстрее сделать рабочий прототип, а затем расширять его функциональность в соответствии с нуждами проекта. При этом система все время поддерживается в рабочем состоянии и виден прогресс! А результаты доступны как можно раньше. Кроме этого происходит устранение рисков на самой ранней стадии - 90% функционала вашей автотест-системы будет работать уже после 10% потраченного времени (естественно, оценка среднепотолочная, некоторые говорят о 20% и 80% соответственно). Например моя любимая последовательность приоритетов следующая:
        <ul><li>2-4 рабочих тест скрипта - снимает риск неправильно выбранного инструмента и распознавания им элементов управления приложения. Позволяет разработать эффективную архитектуру тестовых сценариев (да-да, не все автотесты пишутся рекордингом).</li>
            <li>основная инфраструктура: инсталляция, деинсталляция, восстановление рабочей среды, рассылка результатов - позволяет построить законченную автоматизированную систему и начать ее использование. Соответственно снимает риск неполучения такой системы в финале из-за каких либо программных либо аппаратных проблем или ограничений.</li>
            <li>Оставшиеся тесты - основные риски с совместимостью приложения и инструмента тестирования уже сняты, так что работе почти ничто не мешает.</li>
            <li>Украшательства и статистика - здесь риски еще меньше.</li>
        </ul>
    </li>
</ul>
<ul>
    <li>Популяризация автоматизированного тестирования - Если кто-то имел положительный опыт автоматизации он никогда не забудет ощущение от того как тонны скучной и унылой работы превращаются в интереснейшие и нетривиальные задачи, а затем выполняются в разы быстрее, чем это может сделать человек. А в это время команда ручного тестирования может сосредоточится на действительно важных проблемах!</li>
</ul>
<p>
    Теперь пару слов о том что же представляет собой "визуализация". Возможны 2 варианта которые принципиально схожи, но немного различны в деталях. Назовем их "визуализация на большом проекте" и "визуализация на небольшом проекте". В случае небольшого проекта сосредоточьте свои усилия на менеджере проекта. Это тот кто будет продвигать бюджет по автоматизации.<br/>
    &nbsp;<br/>
    Небольшой проект:<br/>
</p>
<ol>
    <li>Обсуждайте свои задачи с менеджером, даже если вы ставите их себе сами. Вы должны быть уверены что он знает и понимает чем вы сейчас заняты, что вы уже сделали и какие у вас планы.</li>
    <li>Подпишите на свои "рассылки" результатов тестирования как можно больше менеджеров. Им это будет давать ощущение "руки на пульсе" проекта, а вам - фидбэк и саморекламу. Также подпишите интересующихся коллег - они основные генераторы идей, когда у вас идеи уже закончились.</li>
    <li>Постоянно улучшайте, расширяйте и стабилизируйте свою систему - это поможет меньше отвлекаться на проблемы с ней впоследствии, а также поможет быстрее решать новые задачи.</li>
</ol>
<p> На большом проекте вы можете быть предоставлены сами себе с общей целью действовать в интересах команды. В случае если у вас есть непосредственный менеджер - актуален вариант визуализации для небольшого проекта.
    <br/>
    Большой проект:</p>
<ol>
    <li/> Знайте кто решает вопрос быть или не быть автоматизации (т.е. распределяет бюджет). Это может быть не 1 человек. Это может быть в том числе и заказчик!
    <li/> Все то же что и на небольшом проекте, только вместо понятия "менеджер" используйте тех кто попадает в пункт 1 :) Естественно, вы вряд ли сможете обсудить свои задачи со всеми этими людьми, но можно выяснить их интересы (какие фичи сделают их счастливыми) и стимулировать их с помощью своих репортов!
</ol>
<p> Вот как-то так...</p>
<br/>
<p><b>Автор</b>: Владимир Антонов</p>
<br/>
<p class="linktop"><a href="automation_from_scratch.html#top" rel="external nofollow">Наверх</a></p>
</div>
<div class="enddiv">&nbsp;
    <noindex>
        <script>
            function googleTranslateElementInit() {
            new google.translate.TranslateElement({
            pageLanguage: 'ru',
            includedLanguages: 'be,en,fr,de,pl,ru,es,uk',
            multilanguagePage: true,
            gaTrack: true,
            gaId: 'UA-4297293-3'
            });
            }
        </script><script src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-4297293-3']);
            _gaq.push(['_trackPageview']);
            (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
    </noindex>
</div>
</div>
</div>
<div id="footer">
    <table border="0" cellpadding="0" cellspacing="0" align="center">
        <tr>
            <td align="left">
                <table class="inner" border="0" cellpadding="0" cellspacing="0" align="left">
                    <tr><td align="left"><b>ОБРАТНАЯ СВЯЗЬ:</b></td></tr>
                    <tr><td align="left">&nbsp;</td></tr>
                    <tr><td align="left"><a href="../../contact/contact.html">Задать вопрос</a></td></tr>
                    <tr><td align="left"><a href="../../contact/contact.html">Сообщить об ошибке</a></td></tr>
                    <tr><td align="left"><a href="../../contact/contact.html">Публикация материалов</a></td></tr>
                    <tr><td align="left"><a href="../../contact/link.html">Обмен ссылками</a></td></tr>
                </table>
            </td>
            <td align="center"><img src="../../img/protesting125x125_3.gif" alt="Про Тестинг: тесты, тестирование и тестировщики программного обеспечения" width="100" height="100"/>
                <br/>
                <noindex>
                    <script type="text/javascript">
                        var d = new Date();
                        document.write("&copy; 2008-" + d.getFullYear());
                    </script>
                </noindex>
                <a href="../../index.html">ProTesting.ru</a></td>
            <td align="right">
                <table class="inner" border="0" cellpadding="0" cellspacing="0" align="right">
                    <tr><td align="right"><b>УСЛУГИ:</b></td></tr>
                    <tr><td align="right">&nbsp;</td></tr>
                    <tr><td align="right"><a href="../../service/documentation.html">Подготовка&nbsp;документации</a></td></tr>
                    <tr><td align="right"><a href="../../service/testing.html">Тестирование&nbsp;ПО</a></td></tr>
                    <tr><td align="right"><a href="../../service/consulting.html">Консалтинг</a></td></tr>
                </table>
            </td>
        </tr>
    </table>
    <p align="left">
        <!--LiveInternet counter--><script type="text/javascript"><!--
    document.write("<a href='http://www.liveinternet.ru/click' "+
                   "target=_blank><img src='http://counter.yadro.ru/hit?t17.5;r"+
                   escape(document.referrer)+((typeof(screen)=="undefined")?"":
                                              ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
                                                                                       screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
                   ";h"+escape(document.title.substring(0,80))+";"+Math.random()+
                   "' alt='' title='LiveInternet: показано число просмотров за 24"+
                   " часа, посетителей за 24 часа и за сегодня' "+
                   "border=0 width=88 height=31 align=middle/><\/a>")//--></script><!--/LiveInternet-->
    </p>
    <!-- begin of Top100 logo -->
    <a href="http://top100.rambler.ru/home?id=1902383" target="_blank"><img src="http://top100-images.rambler.ru/top100/banner-88x31-rambler-black2.gif" alt="Rambler's Top100" width="88" height="31" border="0" /></a>
    <!-- end of Top100 logo -->
</div>
<!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript" src="http://counter.rambler.ru/top100.jcn?1902383"></script><noscript><img src="http://counter.rambler.ru/top100.cnt?1902383" alt="" width="1" height="1" border="0"/></noscript>
<!-- end of Top100 code -->
</body>
</html>